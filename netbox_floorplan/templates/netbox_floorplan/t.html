{% extends 'base/layout.html' %}
{% load static %}
{% load form_helpers %}
{% load helpers %}

{% block head %}
{{ block.super }}
<!-- <script src="{% static 'netbox_floorplan/fabric.js' %}"></script> -->
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/1.5.0/fabric.js"></script> -->
<script src="{% static 'netbox_floorplan/fabric.js' %}"></script>
<script type="text/javascript" src="{% static 'netbox_floorplan/lodash.js' %}"></script>
<script src="{% static 'netbox_floorplan/jq.js' %}"></script>
<!-- <script src="{% static 'netbox_floorplan/jq-ui.js' %}"></script> -->

{% endblock head %}

{% block title %}
Location Map
{% endblock title %}

{% block tabs %}
<ul class="nav nav-tabs px-3">
    <li class="nav-item" role="presentation">
        <button class="nav-link active" id="edit-tabs-tab" data-bs-toggle="tab" data-bs-target="#edit-tabs"
            type="button" role="tab" aria-controls="edit-tabs" aria-selected="true">
            Test
        </button>
    </li>
</ul>
{% endblock tabs %}

{% block content-wrapper %}
<style>
    #drag_zone {
        box-sizing: content-box;
    }

    .drag {
        z-index: 999;
    }

    .draggable {
        width: 50px;
        height: 50px;
        border: 1px solid black;
        background: #aaa;
        z-index: 999;

    }

    #drag-container {
        padding-right: 1rem
    }

    .draggable-two {
        display: block;
        float: right;
        width: 150px;
        height: 150px;
        border: 1px solid black;
        background: #aaa;
        z-index: 999;
    }

    canvas {
        /**border: 1px solid #999;**/
    }
</style>
<div class="tab-content">
    <div class="tab-pane show active" id="object-list" role="tabpanel" aria-labelledby="object-list-tab">
        <div id="draggable-area">
            <div class="col-md-12">
                <div class="row">
                    <div class="col-md-3">
                        <div class="row">
                            <div class="card">
                                <div class="card-body" id="object_list">
                                    <div id="library" class="container library-container">
                                        <div class="btn btn-sm btn-primary drag prevent-overlap" id="test"
                                            onclick="map_floorplan_object(100, 200, '#ea8fe', 30, '{{ rack.id }}', '{{ rack.name }}'); document.getElementById('{{ rack.id  }}').remove()"
                                            )">
                                            Rack 1</div>
                                        <div class="btn btn-sm btn-primary drag prevent-overlap">Rack 2</div>
                                        <div class="btn btn-sm btn-primary drag prevent-overlap">Rack 3</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-9">
                        <div class="card">
                            <div class="card-body" id="content-container">
                                <div id="drag_zone">
                                    <canvas id="canvas" width="800" height="500"></canvas>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-body" id="tools-control">
                                <div class="d-flex">
                                    <div class="form-check form-switch">
                                        <input class="form-check-input" type="checkbox" id="set_scale">
                                        <label class="form-check-label" for="set_scale">Set Scale</label>
                                    </div>
                                    <div class="mx-2"></div>
                                    <div class="btn btn-sm btn-danger disabled tools"
                                        onclick="delete_floorplan_object()" id="remove_button">
                                        Delete
                                    </div>
                                    <div class="mx-2"></div>
                                    <div class="btn btn-sm btn-primary" onclick="save_floorplan()">
                                        Save
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="modal fade" id="control_unit_modal" tabindex="-1"
                            aria-labelledby="control_unit_modal_label" aria-hidden="true">
                            <div class="modal-dialog">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 class="modal-title" id="control_unit_modal_label">Set Scale</h5>
                                        <button type="button" class="btn-close" data-bs-dismiss="modal"
                                            aria-label="Close"></button>
                                    </div>
                                    <div class="modal-body">
                                        <div class="d-flex">
                                            <input id="scale_value" placeholder="unit" type="number" step="0.01" />
                                            <div class="mx-2"></div>
                                            <select id="scale_unit" class="netbox-static-select">
                                                <option value="ft">Feet</option>
                                                <option value="m">Meters</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="modal-footer">
                                        <button type="button" class="btn btn-secondary"
                                            data-bs-dismiss="modal">Close</button>
                                        <button type="button" class="btn btn-primary" onclick="adjust_scale()">Save
                                            changes</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>

    $('#control_unit_modal').on('hidden.bs.modal', () => {
        canvas.getObjects().forEach(function (object) {
            if (object.obj_type == "control_line") {
                canvas.remove(object);
            }
        });
        canvas.off('mouse:out mouse:over mouse:up mouse:down mouse:move', function (options) { });
    });

    var current_floor_plan_id = null;
    var current_control_line_length_px = null;

    var canvas = new fabric.Canvas('canvas'),
        canvasWidth = document.getElementById('canvas').width,
        canvasHeight = document.getElementById('canvas').height,
        counter = 0,
        snap = 20;

    canvas.on('object:rotating', function (options) {
        var step = 15;
        options.target.angle = Math.round(options.target.angle / step) * step;
    });

    canvas.on({
        "object:deselected": enable_button_selection,
        "object:selected": enable_button_selection
    });
    function enable_button_selection() {
        $(".tools").removeClass("disabled");
    }

    canvas.selection = false;

    let checkbox = document.getElementById('set_scale');
    checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
            var line;
            var is_down;
            var arr = new Array();
            var startx = new Array();
            var endx = new Array();
            var starty = new Array();
            var endy = new Array();
            var temp = 0;
            var trigger = "1";
            canvas.on('mouse:down', function (o) {
                canvas.getObjects().forEach(function (object) {
                    if (object.obj_type == "control_line") {
                        canvas.remove(object);
                    }
                });
                if (trigger == "1") {
                    is_down = true;
                    var pointer = canvas.getPointer(o.e);
                    var points = [pointer.x, pointer.y, pointer.x, pointer.y];
                    startx[temp] = pointer.x;
                    starty[temp] = pointer.y;
                    line = new fabric.Line(points, {
                        strokeWidth: 2,
                        stroke: 'red',
                        originX: 'center',
                        originY: 'center',
                        obj_type: 'control_line'
                    });
                    canvas.add(line);
                } else {
                    canvas.forEachObject(function (o) {
                        o.setCoords();
                    });
                }
            });

            canvas.on('mouse:move', function (o) {
                if (!is_down) return;
                var pointer = canvas.getPointer(o.e);
                line.set({ x2: pointer.x, y2: pointer.y });

                endx[temp] = pointer.x;
                endy[temp] = pointer.y;

                if (trigger == "1") {
                    var px = Calculate.lineLength(startx[temp], starty[temp], endx[temp], endy[temp]).toFixed(2);
                    current_control_line_length_px = px;
                }
                canvas.renderAll();
            });


            canvas.on('mouse:up', function (o) {
                var pointer = canvas.getPointer(o.e);
                is_down = false;
                $('#control_unit_modal').modal('show');
            });

            canvas.on('mouse:over', function (e) {
                e.target.setStroke('blue');
                canvas.renderAll();
            });

            canvas.on('mouse:out', function (e) {
                e.target.setStroke('red');
                canvas.renderAll();
            });

            var Calculate = {
                lineLength: function (x1, y1, x2, y2) {
                    return Math.sqrt(Math.pow(x2 * 1 - x1 * 1, 2) + Math.pow(y2 * 1 - y1 * 1, 2));
                }
            };
        } else {
            console.log("off");
            canvas.off('mouse:out mouse:over mouse:up mouse:down mouse:move', function (options) { });
            init_map();
        }
    });

    function adjust_scale() {
        var scale_unit = document.getElementById("scale_unit").value;
        var scale_value = document.getElementById("scale_value").value;
        $.ajax({
            type: "PATCH",
            url: `/api/plugins/floorplan/floorplans/${current_floor_plan_id}/`,
            dataType: "json",
            headers: {
                "X-CSRFToken": "{{ csrf_token }}",
                "Content-Type": "application/json"
            },
            data: JSON.stringify({
                "measurement_unit": scale_unit,
                "scale": scale_value,
            }),
            error: function (err) {
                console.log(`Error: ${err}`);
            }
        });
        $('#control_unit_modal').modal('hide');
    };


    function map_floorplan_object(width, height, fill, rotation, id) {
        var top = 300;
        var left = 500;

        var rect = new fabric.Rect({
            top: top,
            name: "rectangle",
            left: left,
            width: width,
            height: height,
            fill: fill,
            opacity: 0.8,
            lockRotation: false,
            originX: "center",
            originY: "center",
            cornerSize: 15,
            hasRotatingPoint: true,
            perPixelTargetFind: true,
            minScaleLimit: 1,
            maxWidth: canvasWidth,
            maxHeight: canvasHeight,
        });

        rect.custom = {};
        rect.custom.counter = counter;

        var text = new fabric.IText("test", {
            fontFamily: "Courier New",
            fontSize: 16,
            fill: "#FFFF",
            textAlign: "center",
            originX: "center",
            originY: "center",
            left: left,
            top: top,
            excludeFromExport: false,
            includeDefaultValues: true,
        });

        var group = new fabric.Group([rect, text]);

        group.setControlsVisibility({
            mt: false,
            mb: false,
            ml: false,
            mr: false,
            bl: false,
            br: false,
            tl: false,
            tr: false,
        })

        //group.setPosition(top, left);
        group.setAngle(rotation);

        if (id) {
            group.set('id', id);
        }

        canvas.add(group);
        counter++;
    }

    function delete_floorplan_object() {
        var object = canvas.getActiveObject();
        if (object) {
            canvas.remove(object);
        }
        disable_button_selection();
    };

    function disable_button_selection() {
        if (!$(".tools").hasClass("disabled")) {
            $(".tools").addClass("disabled");
        }
    }

    function set_new_position(dist_x, dist_y, target, obj) {
        // See whether to focus on X or Y axis
        if (Math.abs(dist_x) > Math.abs(dist_y)) {
            if (dist_x > 0) {
                target.setLeft(obj.getLeft() - target.getWidth());
            } else {
                target.setLeft(obj.getLeft() + obj.getWidth());
            }
        } else {
            if (dist_y > 0) {
                target.setTop(obj.getTop() - target.getHeight());
            } else {
                target.setTop(obj.getTop() + obj.getHeight());
            }
        }
    }

    function save_floorplan() {
        var floor_json = canvas.toJSON(["id", "text", "_controlsVisibility"]);

        console.log(JSON.stringify(floor_json));
        $.ajax({
            type: "PATCH",
            url: `/api/plugins/floorplan/floorplans/${current_floor_plan_id}/`,
            dataType: "json",
            headers: {
                "X-CSRFToken": "{{ csrf_token }}",
                "Content-Type": "application/json"
            },
            data: JSON.stringify({
                "canvas": floor_json,
            }),
            error: function (err) {
                console.log(`Error: ${err}`);
            }
        });
    }

    canvas.on('object:moving', function (options) {
        // Sets corner position coordinates based on current angle, width and height
        options.target.setCoords();

        // Don't allow objects off the canvas
        if (options.target.getLeft() < snap) {
            options.target.setLeft(0);
        }

        if (options.target.getTop() < snap) {
            options.target.setTop(0);
        }

        if ((options.target.getWidth() + options.target.getLeft()) > (canvasWidth - snap)) {
            options.target.setLeft(canvasWidth - options.target.getWidth());
        }

        if ((options.target.getHeight() + options.target.getTop()) > (canvasHeight - snap)) {
            options.target.setTop(canvasHeight - options.target.getHeight());
        }

        // Loop through objects
        canvas.forEachObject(function (obj) {
            if (obj === options.target) return;

            // If objects intersect
            if (options.target.isContainedWithinObject(obj) || options.target.intersectsWithObject(obj) || obj.isContainedWithinObject(options.target)) {

                var dist_x = ((obj.getLeft() + obj.getWidth()) / 2) - ((options.target.getLeft() + options.target.getWidth()) / 2);
                var dist_y = ((obj.getTop() + obj.getHeight()) / 2) - ((options.target.getTop() + options.target.getHeight()) / 2);

                set_new_position(dist_x, dist_y, options.target, obj);
            }

            // Snap objects to each other horizontally

            // If bottom points are on same Y axis
            if (Math.abs((options.target.getTop() + options.target.getHeight()) - (obj.getTop() + obj.getHeight())) < snap) {
                // Snap target BL to object BR
                if (Math.abs(options.target.getLeft() - (obj.getLeft() + obj.getWidth())) < snap) {
                    options.target.setLeft(obj.getLeft() + obj.getWidth());
                    options.target.setTop(obj.getTop() + obj.getHeight() - options.target.getHeight());
                }

                // Snap target BR to object BL
                if (Math.abs((options.target.getLeft() + options.target.getWidth()) - obj.getLeft()) < snap) {
                    options.target.setLeft(obj.getLeft() - options.target.getWidth());
                    options.target.setTop(obj.getTop() + obj.getHeight() - options.target.getHeight());
                }
            }

            // If top points are on same Y axis
            if (Math.abs(options.target.getTop() - obj.getTop()) < snap) {
                // Snap target TL to object TR
                if (Math.abs(options.target.getLeft() - (obj.getLeft() + obj.getWidth())) < snap) {
                    options.target.setLeft(obj.getLeft() + obj.getWidth());
                    options.target.setTop(obj.getTop());
                }

                // Snap target TR to object TL
                if (Math.abs((options.target.getLeft() + options.target.getWidth()) - obj.getLeft()) < snap) {
                    options.target.setLeft(obj.getLeft() - options.target.getWidth());
                    options.target.setTop(obj.getTop());
                }
            }

            // Snap objects to each other vertically

            // If right points are on same X axis
            if (Math.abs((options.target.getLeft() + options.target.getWidth()) - (obj.getLeft() + obj.getWidth())) < snap) {
                // Snap target TR to object BR
                if (Math.abs(options.target.getTop() - (obj.getTop() + obj.getHeight())) < snap) {
                    options.target.setLeft(obj.getLeft() + obj.getWidth() - options.target.getWidth());
                    options.target.setTop(obj.getTop() + obj.getHeight());
                }

                // Snap target BR to object TR
                if (Math.abs((options.target.getTop() + options.target.getHeight()) - obj.getTop()) < snap) {
                    options.target.setLeft(obj.getLeft() + obj.getWidth() - options.target.getWidth());
                    options.target.setTop(obj.getTop() - options.target.getHeight());
                }
            }

            // If left points are on same X axis
            if (Math.abs(options.target.getLeft() - obj.getLeft()) < snap) {
                // Snap target TL to object BL
                if (Math.abs(options.target.getTop() - (obj.getTop() + obj.getHeight())) < snap) {
                    options.target.setLeft(obj.getLeft());
                    options.target.setTop(obj.getTop() + obj.getHeight());
                }

                // Snap target BL to object TL
                if (Math.abs((options.target.getTop() + options.target.getHeight()) - obj.getTop()) < snap) {
                    options.target.setLeft(obj.getLeft());
                    options.target.setTop(obj.getTop() - options.target.getHeight());
                }
            }
        });

        // var debounced_update_object_position = _.debounce(update_object_position, 1000);
        // function update_object_position() {
        //     var object = canvas.getActiveObject();
        //     var fp_object_id = object.get("id");

        //     $.ajax({
        //         type: "PATCH",
        //         url: `/api/plugins/floorplan/floorplan-objects/${fp_object_id}/`,
        //         dataType: "json",
        //         headers: {
        //             "X-CSRFToken": "{{ csrf_token }}",
        //             "Content-Type": "application/json"
        //         },
        //         data: JSON.stringify({
        //             "x_coordinate": object.getTop(),
        //             "y_coordinate": object.getLeft(),
        //             "rotation": object.angle,
        //         }),
        //         error: function (err) {
        //             console.log(`Error: ${err}`);
        //         }
        //     });

        //     console.log(`id is ${fp_object_id}`);
        //     console.log(object.getLeft());
        //     console.log(object.getTop());
        //     console.log(object.angle);
        // }

        // canvas.on({
        //     "object:modified": debounced_update_object_position,
        // });

        options.target.setCoords();

        var outer_area_left = null,
            outer_area_top = null,
            outer_area_right = null,
            outer_area_bottom = null;

        canvas.forEachObject(function (obj) {
            if (obj === options.target) return;

            if (options.target.isContainedWithinObject(obj) || options.target.intersectsWithObject(obj) || obj.isContainedWithinObject(options.target)) {

                var intersect_left = null,
                    intersect_top = null,
                    intersect_width = null,
                    intersect_height = null,
                    intersect_size = null,
                    target_left = options.target.getLeft(),
                    target_right = target_left + options.target.getWidth(),
                    target_top = options.target.getTop(),
                    target_bottom = target_top + options.target.getHeight(),
                    object_left = obj.getLeft(),
                    object_right = object_left + obj.getWidth(),
                    object_top = obj.getTop(),
                    object_bottom = object_top + obj.getHeight();

                // Find intersect information for X axis
                if (target_left >= object_left && target_left <= object_right) {
                    intersect_left = target_left;
                    intersect_width = obj.getWidth() - (intersect_left - object_left);

                } else if (object_left >= target_left && object_left <= target_right) {
                    intersect_left = object_left;
                    intersect_width = options.target.getWidth() - (intersect_left - target_left);
                }

                // Find intersect information for Y axis
                if (target_top >= object_top && target_top <= object_bottom) {
                    intersect_top = target_top;
                    intersect_height = obj.getHeight() - (intersect_top - object_top);

                } else if (object_top >= target_top && object_top <= target_bottom) {
                    intersect_top = object_top;
                    intersect_height = options.target.getHeight() - (intersect_top - target_top);
                }

                // Find intersect size (this will be 0 if objects are touching but not overlapping)
                if (intersect_width > 0 && intersect_height > 0) {
                    intersect_size = intersect_width * intersect_height;
                }

                // Set outer snapping area
                if (obj.getLeft() < outer_area_left || outer_area_left == null) {
                    outer_area_left = obj.getLeft();
                }

                if (obj.getTop() < outer_area_top || outer_area_top == null) {
                    outer_area_top = obj.getTop();
                }

                if ((obj.getLeft() + obj.getWidth()) > outer_area_right || outer_area_right == null) {
                    outer_area_right = obj.getLeft() + obj.getWidth();
                }

                if ((obj.getTop() + obj.getHeight()) > outer_area_bottom || outer_area_bottom == null) {
                    outer_area_bottom = obj.getTop() + obj.getHeight();
                }

                // If objects are intersecting, reposition outside all shapes which touch
                if (intersect_size) {
                    var dist_x = (outer_area_right / 2) - ((options.target.getLeft() + options.target.getWidth()) / 2);
                    var dist_y = (outer_area_bottom / 2) - ((options.target.getTop() + options.target.getHeight()) / 2);

                    // Set new position
                    set_new_position(dist_x, dist_y, options.target, obj);
                }
            }
        });
    });

    function init_map() {
        // get the obhject id from the url first (not done)
        const floorplan_call = $.get("/api/plugins/floorplan/floorplans/");
        floorplan_call.done(function (floorplan) {
            floorplan.results.forEach((floorplan) => {
                current_floor_plan_id = floorplan.id;
                canvas.loadFromJSON(JSON.stringify(floorplan.canvas), canvas.renderAll.bind(canvas), function (o, object) {
                    fabric.log(o, object);
                });
            });
        }).fail(function (jq_xhr, text_status, error_thrown) {
            console.log(`Error: ${error_thrown} - ${text_status}`);
        });
    };

    $(document).ready(function () {
        init_map();

        // const floorplan_object_call = $.get("/api/plugins/floorplan/floorplan-objects/");
        // floorplan_object_call.done(function (floorplan_object_json) {
        //     floorplan_object_json.results.forEach((floorplan_object) => {

        //         map_floorplan_object(floorplan_object.x_coordinate, floorplan_object.y_coordinate, 100, 200, "#6ea8fe", floorplan_object.rotation, floorplan_object.id)
        //     });
        // }).fail(function (jq_xhr, text_status, error_thrown) {
        //     console.log(`Error: ${error_thrown} - ${text_status}`);
        // });

    });

</script>


<!-- <script>
// $(".drag").draggable({
// obstacle: ".prevent-overlap",
// containment: "#drag_zone",
// collision: true,
// distance: 10,
// snap: true,
// snapMode: "outer",
// start: function (event, ui) {
// $(this).removeClass('prevent-overlap');
// // $(this).addClass('draggable');
// // $(this).addClass('draggable-two');
// },
// stop: function (event, ui) {
// $(this).addClass('prevent-overlap');
// //alert(JSON.stringify(ui.position));
// }
// });

// $(document).ready(function () {
// $("#test").position({ top: 248, left: 471 });
// });

// var degrees = 0;
// $('.drag').click(function rotateMe(e) {
// console.log("test");
// degrees += 90;
// $('.drag').css({
// 'transform': 'rotate(' + degrees + 'deg)',
// '-ms-transform': 'rotate(' + degrees + 'deg)',
// '-moz-transform': 'rotate(' + degrees + 'deg)',
// '-webkit-transform': 'rotate(' + degrees + 'deg)',
// '-o-transform': 'rotate(' + degrees + 'deg)'
// });
// });



    // var control_line_pixel_length = null;

    // var canvas = document.getElementById('canvas');
    // var ctx = canvas.getContext("2d");
    // canvas.addEventListener('mousedown', mouseDown, false);
    // canvas.addEventListener('mousemove', mouseMove, false);
    // canvas.addEventListener('mouseup', mouseUp, false);
    // var mouseDown = false;
    // var points = [];
    // var lines = [];
    // var linePoint = [];
    // var stPoint;
    // var endPoint;



    // function draw_canvas_background(canvas_context) {
    //     var imageObj = new Image();
    //     imageObj.onload = function () {
    //         ctx.drawImage(imageObj, 0, 0, canvas.width, canvas.height);
    //     };
    //     imageObj.src = '/static/netbox_logo.svg';
    // };
    // draw_canvas_background(ctx);

    // let cvs = document.getElementById("canvas");
    // cvs.width = document.querySelector("#content-container").getBoundingClientRect().width - 20;
    // cvs.height = document.querySelector("#content-container").getBoundingClientRect().height;

    // window.addEventListener("resize", () => {
    //     cvs_width = document.querySelector("#content-container").getBoundingClientRect().width - 20;
    //     cvs_height = document.querySelector("#content-container").getBoundingClientRect().height;

    //     cvs.width = cvs_width;
    //     cvs.height = cvs_height;
    //     canvas_context = canvas.getContext("2d").clearRect(0, 0, cvs_width, cvs_height);

    //     draw_canvas_background(canvas_context);
    // });

    // function Point(x, y) {
    //     this.x = x;
    //     this.y = y;
    // }

    // function lineP(stPoint, endPoint) {
    //     this.stPoint = stPoint;
    //     this.endPoint = endPoint;
    // }

    // function mouseDown(e) {
    //     mouseDown = true;
    //     linePoint = [];
    //     stPoint = new Point(e.layerX, e.layerY); //get start point for line
    // }

    // function mouseMove(e) {
    //     if (!mouseDown) return;
    //     ctx.clearRect(0, 0, canvas.width, canvas.height); //clear canvas
    //     //ctx.drawImage(imageObj, 0, 0, canvas.width, canvas.height); //redraw image
    //     draw_canvas_background(ctx);
    //     ctx.beginPath();
    //     ctx.moveTo(stPoint.x, stPoint.y);
    //     ctx.lineTo(e.layerX, e.layerY);
    //     ctx.stroke();
    //     ctx.lineWidth = 5;
    //     ctx.strokeStyle = "#FF0000";
    //     ctx.closePath();
    //     let length = Math.sqrt((stPoint.x - e.layerX) ** 2 + (stPoint.y - e.layerY) ** 2);
    //     control_line_pixel_length = length;
    //     console.log(`Length of the line in pixels is: ${length}`);
    // }

    // function mouseUp(e) {
    //     mouseDown = false;
    //     endPoint = new Point(e.layerX, e.layerY); //get end point
    //     linePoint.push(new lineP(stPoint, endPoint)); //store line points for next draw
    //     console.log(linePoint);
    // }

    //(function (window) {

    // holds all our boxes
    var racks = [];

    // New, holds the 8 tiny boxes that will be our selection handles
    // the selection handles will be in this order:
    // 0  1  2
    // 3     4
    // 5  6  7
    var selectionHandles = [];

    // Hold canvas information
    var canvas;
    var ctx;
    var WIDTH;
    var HEIGHT;
    var INTERVAL = 20;  // how often, in milliseconds, we check to see if a redraw is needed

    var isDrag = false;
    var isResizeDrag = false;
    var expectResize = -1; // New, will save the # of the selection handle if the mouse is over one.
    var mx, my; // mouse coordinates

    // when set to true, the canvas will redraw everything
    // invalidate() just sets this to false right now
    // we want to call invalidate() whenever we make a change
    var canvasValid = false;

    // The node (if any) being selected.
    // If in the future we want to select multiple objects, this will get turned into an array
    var mySel = null;

    // The selection color and width. Right now we have a red selection with a small width
    var mySelColor = '#FFFFFF';
    var mySelWidth = 2;
    var mySelBoxColor = 'darkred'; // New for selection boxes
    var mySelBoxSize = 6;

    // we use a fake canvas to draw individual shapes for selection testing
    var ghostcanvas;
    var gctx; // fake canvas context

    // since we can drag from anywhere in a node
    // instead of just its x/y corner, we need to save
    // the offset of the mouse when we start dragging.
    var offsetx, offsety;

    // Padding and border style widths for mouse offsets
    var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;


    function disable_button_selection() {
        if (!$(".tools").hasClass("disabled")) {
            $(".tools").addClass("disabled");
        }
    }



    // Box object to hold data
    function Rack() {
        this.x = 0;
        this.y = 0;
        this.w = 1; // default width and height?
        this.h = 1;
        this.fill = '#444444';
        this.id = 0;
        this.rotation = 0;
        this.name = "Rack";
    }

    // New methods on the Box class
    Rack.prototype = {

        draw: function (context, optionalColor) {
            if (context === gctx) {
                context.fillStyle = 'black'; // always want black for the ghost canvas
            } else {
                context.fillStyle = this.fill;
            }

            // We can skip the drawing of elements that have moved off the screen:
            if (this.x > WIDTH || this.y > HEIGHT) return;
            if (this.x + this.w < 0 || this.y + this.h < 0) return;

            // context.save();
            // context.rotate(Math.PI / 2);

            context.fillRect(this.x, this.y, this.w, this.h);
            context.font = "20px Arial";
            context.textAlign = "center";
            context.fillStyle = "white";
            context.textBaseline = "middle";
            context.fillText(this.name, this.x + (this.w / 2), this.y + (this.h / 2));
            // draw selection
            // this is a stroke along the box and also 8 new selection handles
            if (mySel === this) {
                context.strokeStyle = mySelColor;
                context.lineWidth = mySelWidth;
                context.strokeRect(this.x, this.y, this.w, this.h);

                // // draw the boxes

                // var half = mySelBoxSize / 2;

                // // 0  1  2
                // // 3     4
                // // 5  6  7

                // // top left, middle, right
                // selectionHandles[0].x = this.x - half;
                // selectionHandles[0].y = this.y - half;

                // selectionHandles[1].x = this.x + this.w / 2 - half;
                // selectionHandles[1].y = this.y - half;

                // selectionHandles[2].x = this.x + this.w - half;
                // selectionHandles[2].y = this.y - half;

                // //middle left
                // selectionHandles[3].x = this.x - half;
                // selectionHandles[3].y = this.y + this.h / 2 - half;

                // //middle right
                // selectionHandles[4].x = this.x + this.w - half;
                // selectionHandles[4].y = this.y + this.h / 2 - half;

                // //bottom left, middle, right
                // selectionHandles[6].x = this.x + this.w / 2 - half;
                // selectionHandles[6].y = this.y + this.h - half;

                // selectionHandles[5].x = this.x - half;
                // selectionHandles[5].y = this.y + this.h - half;

                // selectionHandles[7].x = this.x + this.w - half;
                // selectionHandles[7].y = this.y + this.h - half;


                // context.fillStyle = mySelBoxColor;
                // for (var i = 0; i < 8; i++) {
                //     var cur = selectionHandles[i];
                //     context.fillRect(cur.x, cur.y, mySelBoxSize, mySelBoxSize);
                // }
            }
            console.log(`${this.x} ` + ` ${this.y}`);
        } // end draw

    }

    //Initialize a new Box, add it, and invalidate the canvas
    function addRect(x, y, w, h, fill, id, rotation, name) {
        var rect = new Rack;
        rect.x = x;
        rect.y = y;
        rect.w = w
        rect.h = h;
        rect.fill = fill;
        this.id = id;
        this.rotation = rotation;
        this.name = name;
        racks.push(rect);
        invalidate();
    }

    // initialize our canvas, add a ghost canvas, set draw loop
    // then add everything we want to intially exist on the canvas
    function init_floorplan() {
        canvas = document.getElementById('canvas');
        HEIGHT = canvas.height;
        WIDTH = canvas.width;
        ctx = canvas.getContext('2d');
        ghostcanvas = document.createElement('canvas');
        ghostcanvas.height = HEIGHT;
        ghostcanvas.width = WIDTH;
        gctx = ghostcanvas.getContext('2d');

        //fixes a problem where double clicking causes text to get selected on the canvas
        canvas.onselectstart = function () { return false; }

        // fixes mouse co-ordinate problems when there's a border or padding
        // see getMouse for more detail
        if (document.defaultView && document.defaultView.getComputedStyle) {
            stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingLeft'], 10) || 0;
            stylePaddingTop = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingTop'], 10) || 0;
            styleBorderLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderLeftWidth'], 10) || 0;
            styleBorderTop = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderTopWidth'], 10) || 0;
        }

        // make mainDraw() fire every INTERVAL milliseconds
        setInterval(mainDraw, INTERVAL);

        // set our events. Up and down are for dragging,
        // double click is for making new boxes
        canvas.onmousedown = myDown;
        canvas.onmouseup = myUp;
        //canvas.ondblclick = myDblClick;
        canvas.onmousemove = myMove;


        // add a large green rectangle
        addRect(260, 70, 60, 65, 'rgba(0,205,0,0.7)', 0, 0, "Rack 1");

        // add a green-blue rectangle
        addRect(240, 120, 40, 40, 'rgba(2,165,165,0.7)', 0, 0, "Rack 2");

        // add a smaller purple rectangle
        addRect(45, 60, 25, 25, 'rgba(150,150,250,0.7)', 0, 0, "Rack 3");
    }


    //wipes the canvas context
    function clear(c) {
        c.clearRect(0, 0, WIDTH, HEIGHT);
    }

    function mainDraw() {
        if (canvasValid == false) {
            clear(ctx);

            // Add stuff you want drawn in the background all the time here

            // draw all boxes
            var l = racks.length;
            for (var i = 0; i < l; i++) {
                racks[i].draw(ctx); // we used to call drawshape, but now each box draws itself
            }

            // Add stuff you want drawn on top all the time here

            canvasValid = true;
        }
    }

    // Happens when the mouse is moving inside the canvas
    function myMove(e) {
        if (isDrag) {
            getMouse(e);

            mySel.x = mx - offsetx;
            mySel.y = my - offsety;

            invalidate();


            invalidate();
        }

        getMouse(e);
    }

    // Happens when the mouse is clicked in the canvas
    function myDown(e) {
        console.log("myDown");
        getMouse(e);

        //we are over a selection box
        if (expectResize !== -1) {
            isResizeDrag = true;
            return;
        }

        clear(gctx);
        var l = racks.length;
        for (var i = l - 1; i >= 0; i--) {
            // draw shape onto ghost context
            racks[i].draw(gctx, 'black');

            // get image data at the mouse x,y pixel
            var imageData = gctx.getImageData(mx, my, 1, 1);
            var index = (mx + my * imageData.width) * 4;

            // if the mouse pixel exists, select and break
            if (imageData.data[3] > 0) {
                mySel = racks[i];
                console.log("test");
                $(".tools").removeClass("disabled");
                offsetx = mx - mySel.x;
                offsety = my - mySel.y;
                mySel.x = mx - offsetx;
                mySel.y = my - offsety;
                isDrag = true;

                invalidate();
                clear(gctx);
                return;
            }

        }
        // havent returned means we have selected nothing
        mySel = null
        disable_button_selection();
        // clear the ghost canvas for next time
        clear(gctx);
        // invalidate because we might need the selection border to disappear
        invalidate();
    }

    function myUp() {
        isDrag = false;
        isResizeDrag = false;
        expectResize = -1;
    }

    // adds a new node
    function map_floorplan_object(e) {
        //getMouse(e);
        // for this method width and height determine the starting X and Y, too.
        // so I left them as vars in case someone wanted to make them args for something and copy this code

        let x = ctx.getTransform().e + 50;
        let y = ctx.getTransform().f + 50;
        console.log(`x: ${x}, y: ${y}`);

        var width = 20;
        var height = 20;
        addRect(x - (width / 2), y - (height / 2), width, height, 'rgba(220,205,65,0.7)', 0, 0, "Rack 1");
    }

    function delete_floorplan_object(node_idex) {
        racks.splice(node_idex, 1);
        invalidate();
        disable_button_selection();
    };

    function rotate_node() {
        mySel.rotation += 90;
        invalidate();
    }

    function invalidate() {
        canvasValid = false;
    }

    // Sets mx,my to the mouse position relative to the canvas
    // unfortunately this can be tricky, we have to worry about padding and borders
    function getMouse(e) {
        var element = canvas, offsetX = 0, offsetY = 0;

        if (element.offsetParent) {
            do {
                offsetX += element.offsetLeft;
                offsetY += element.offsetTop;
            } while ((element = element.offsetParent));
        }

        // Add padding and border style widths to offset
        offsetX += stylePaddingLeft;
        offsetY += stylePaddingTop;

        offsetX += styleBorderLeft;
        offsetY += styleBorderTop;

        mx = e.pageX - offsetX;
        my = e.pageY - offsetY
    }

    $(document).ready(function () {
        // Your code here
        init_floorplan();
    });




</script> -->
{% endblock content-wrapper %}